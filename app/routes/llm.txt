from fastapi import APIRouter
from pydantic import BaseModel
from typing import List, Optional
import requests
import json

# =====================================
# CONFIG
# =====================================
GOOGLE_API_KEY = "AIzaSyCSB2VvJkwkCcHbXL5m1ganWJ3xn15Pui8"

PRIMARY_MODEL = "gemini-2.5-flash-lite"   # Modelo principal
SECONDARY_MODEL = "gemini-2.0-flash-lite" # Fallback
BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models"

# =====================================
# MODELOS Pydantic
# =====================================
class PlayerState(BaseModel):
    nome: str
    hp: int
    max_hp: int

class EnemyState(BaseModel):
    nome: str
    hp: int
    max_hp: int
    descricao: str       # NOVO: descrição da lenda
    ataqueEspecial: str  # NOVO: ataque especial

class GameState(BaseModel):
    player: PlayerState
    enemy: EnemyState
    chapter: str
    narrative: str
    choices: Optional[List[str]] = []

class StartGameRequest(BaseModel):
    state: GameState

class PlayerAction(BaseModel):
    action: str
    state: GameState

llm_router = APIRouter(prefix="/llm", tags=["LLM"])

# =====================================
# FUNÇÕES DE CHAMADA LLM
# =====================================
def call_gemini_model(prompt: str, model: str, max_output_tokens: int = 1000) -> str:
    """Chama um modelo específico do Gemini"""
    url = f"{BASE_URL}/{model}:generateContent?key={GOOGLE_API_KEY}"
    data = {
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"temperature": 0.5, "maxOutputTokens": max_output_tokens}
    }
    response = requests.post(url, headers={"Content-Type": "application/json"}, json=data, timeout=15)
    response.raise_for_status()
    resp_json = response.json()
    return resp_json["candidates"][0]["content"]["parts"][0]["text"].strip()


def call_gemini_with_fallback(prompt: str, max_output_tokens: int = 1000) -> str:
    """Tenta modelo primário -> secundário -> JSON fixo"""
    try:
        return call_gemini_model(prompt, PRIMARY_MODEL, max_output_tokens)
    except Exception as e1:
        print("Erro no modelo primário:", e1)

    try:
        return call_gemini_model(prompt, SECONDARY_MODEL, max_output_tokens)
    except Exception as e2:
        print("Erro no modelo secundário:", e2)

    print("Todos os modelos falharam, usando narrativa padrão")
    return '{"narrativa": ["O encontro começa..."], "escolhas": ["Atacar", "Defender", "Usar Item"], "status": {}, "turn_result": {}}'

# =====================================
# UTILITÁRIOS
# =====================================
def safe_json_parse(text: str) -> dict:
    """Converte string JSON para dict seguro"""
    try:
        data = json.loads(text)
    except:
        try:
            start = text.find("{")
            end = text.rfind("}") + 1
            data = json.loads(text[start:end])
        except:
            data = {"narrativa": [text], "escolhas": ["Atacar", "Defender", "Usar Item"], "status": {}, "turn_result": {}}

    narrativa = []
    if "narrativa" in data and isinstance(data["narrativa"], list):
        narrativa = data["narrativa"]
    elif "narrativa" in data and isinstance(data["narrativa"], str):
        narrativa = [line.strip() for line in data["narrativa"].split("\n") if line.strip()]

    escolhas = data.get("escolhas") or data.get("choices") or ["Atacar", "Defender", "Usar Item"]
    status = data.get("status") or {}
    default_turn_result = {
        "player": {"hp_change": 0},
        "enemy": {"hp_change": 0}
    }
    turn_result = {**default_turn_result, **data.get("turn_result", {})}

    return {
        "narrativa": narrativa,
        "escolhas": escolhas,
        "status": status,
        "turn_result": turn_result
    }

def check_game_over(player: dict, enemy: dict) -> Optional[dict]:
    """Verifica se o jogo terminou"""
    if player["hp"] <= 0:
        return {"game_over": True, "winner": "enemy", "loser": "player"}
    elif enemy["hp"] <= 0:
        return {"game_over": True, "winner": "player", "loser": "enemy"}
    return None

# =====================================
# FUNÇÕES DE GERAÇÃO
# =====================================




def generate_dynamic_turn(player_action: str, game_state: dict) -> dict:
    # Inclui descrição e ataque especial da lenda no prompt
    prompt = f"""
Você é um mestre de RPG.
O jogador digitou: "{player_action}".
Capítulo: {game_state['chapter']}
O jogador: {json.dumps(game_state['player'], ensure_ascii=False)}
A lenda: {json.dumps(game_state['enemy'], ensure_ascii=False)}

História da lenda: {game_state['enemy'].get('descricao')}
Ataque especial: {game_state['enemy'].get('ataqueEspecial')}

Regras:
- Use a história, descrição e ataque especial da lenda
- Não coloque HP na narrativa
- Narre a luta de forma zoeira e cômica
- Sugira 3 próximas ações
- Forneça resumo das mudanças de HP separadamente no campo 'turn_result'
- Sempre forneça valores numéricos corretos no 'turn_result'
- Responda apenas em JSON válido no formato:
{{
  "narrativa": ["..."],
  "escolhas": ["...", "...", "..."],
  "status": {{
    "player": {{...}},
    "enemy": {{...}}
  }},
  "turn_result": {{}}
}}
"""
    text = call_gemini_with_fallback(prompt, max_output_tokens=1000)
    data = safe_json_parse(text)

    # Garantir que turn_result exista
    if "turn_result" not in data or not isinstance(data["turn_result"], dict):
        data["turn_result"] = {"player": {"hp_change": 0}, "enemy": {"hp_change": 0}}
    else:
        data["turn_result"]["player"] = data["turn_result"].get("player", {"hp_change": 0})
        data["turn_result"]["enemy"] = data["turn_result"].get("enemy", {"hp_change": 0})

    # Prioriza e aplica valores de dano/HP dos campos de nível superior:
    
    # 1. Dano recebido (sempre diminui o HP, valor negativo)
    if "player_damage_taken" in data:
        data["turn_result"]["player"]["hp_change"] = -abs(data["player_damage_taken"])
    if "enemy_damage_taken" in data:
        data["turn_result"]["enemy"]["hp_change"] = -abs(data["enemy_damage_taken"])
        
    # NOVO: Lógica para os campos 'player_damage' e 'enemy_damage'
    if "player_damage" in data:
        # Player deu dano: diminui HP do inimigo
        data["turn_result"]["enemy"]["hp_change"] = -abs(data["player_damage"])
    if "enemy_damage" in data:
        # Inimigo deu dano: diminui HP do player
        data["turn_result"]["player"]["hp_change"] = -abs(data["enemy_damage"])

    # 2. Mudança de HP (pode ser positivo ou negativo, prioriza este se existir)
    if "player_hp_change" in data:
        data["turn_result"]["player"]["hp_change"] = data["player_hp_change"]
    if "enemy_hp_change" in data:
        data["turn_result"]["enemy"]["hp_change"] = data["enemy_hp_change"]


    # Aplica o dano no status
    player_hp = game_state["player"]["hp"] + data["turn_result"]["player"]["hp_change"]
    enemy_hp = game_state["enemy"]["hp"] + data["turn_result"]["enemy"]["hp_change"]

    # Limita para não ficar negativo
    player_hp = max(0, player_hp)
    enemy_hp = max(0, enemy_hp)

    data["status"] = {
        "player": {**game_state["player"], "hp": player_hp},
        "enemy": {**game_state["enemy"], "hp": enemy_hp}
    }

    # Atualiza objetos principais
    data["player"] = data["status"]["player"]
    data["enemy"] = data["status"]["enemy"]

    # Checagem de game over
    game_over = check_game_over(data["status"]["player"], data["status"]["enemy"])
    if game_over:
        data["game_over"] = game_over

    return data



















def generate_initial_narrative(game_state: dict) -> dict:
    # Inclui descrição e ataque especial da lenda no prompt
    prompt = f"""
Você é um mestre de RPG maluco e engraçado.
Inicie o capítulo: {game_state['chapter']}
O jogador: {json.dumps(game_state['player'], ensure_ascii=False)}
A lenda: {json.dumps(game_state['enemy'], ensure_ascii=False)}

História da lenda: {game_state['enemy'].get('descricao')}
Ataque especial: {game_state['enemy'].get('ataqueEspecial')}

Regras:
- Narre a entrada da lenda e do jogador de forma zoeira
- Use a descrição e ataque especial da lenda
- Sugira 3 ações iniciais
- Responda apenas em JSON válido no formato:
{{
  "narrativa": ["..."],
  "escolhas": ["...", "...", "..."],
  "status": {{
    "player": {{...}},
    "enemy": {{...}}
  }}
}}
"""
    text = call_gemini_with_fallback(prompt, max_output_tokens=800)
    data = safe_json_parse(text)

    if not data["status"]:
        data["status"] = {"player": game_state["player"], "enemy": game_state["enemy"]}
    return data

# =====================================
# ENDPOINTS
# =====================================
@llm_router.post("/start_game")
def start_game(request: StartGameRequest):
    game_state = request.state.dict()
    response = generate_initial_narrative(game_state)
    return response

@llm_router.post("/turn")
def process_turn(action: PlayerAction):
    game_state = action.state.dict()
    response = generate_dynamic_turn(action.action, game_state)

    game_over = check_game_over(response["status"]["player"], response["status"]["enemy"])
    if game_over:
        response["game_over"] = game_over

    return response